package com.example.ghostlib.multiblock;

import com.example.ghostlib.registry.ModBlockEntities;
import com.example.voltlink.api.IVoltReceiver;
import net.minecraft.core.BlockPos;
import net.minecraft.core.HolderLookup;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.neoforged.neoforge.energy.EnergyStorage;

public class ElectricFurnaceControllerBlockEntity extends BlockEntity implements IMultiblockController, IVoltReceiver {
    
    private final EnergyStorage energyStorage = new EnergyStorage(500000, 10000, 10000);
    private boolean isAssembled = false;
    private int cookTime = 0;
    private static final int COOK_TIME_TOTAL = 100; // 5 seconds
    private static final int ENERGY_PER_TICK = 50;

    public ElectricFurnaceControllerBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlockEntities.ELECTRIC_FURNACE_CONTROLLER.get(), pos, state);
    }

    @Override
    public void onLoad() {
        super.onLoad();
        if (level != null && !level.isClientSide) {
            com.example.voltlink.network.GridManager.get(level).subscribe(this, level);
        }
    }

    @Override
    public void setRemoved() {
        if (level != null && !level.isClientSide) {
            com.example.voltlink.network.GridManager.get(level).unsubscribe(this, level);
        }
        super.setRemoved();
    }

    @Override
    public long getVoltDemand() {
        return energyStorage.getEnergyStored() < energyStorage.getMaxEnergyStored() ? 200 : 0;
    }

    @Override
    public void onVoltReceive(long amount) {
        energyStorage.receiveEnergy((int) amount, false);
    }

    @Override
    public BlockPos getVoltPos() {
        return getBlockPos();
    }

    public static void tick(Level level, BlockPos pos, BlockState state, ElectricFurnaceControllerBlockEntity be) {
        if (level.isClientSide || !be.isAssembled) return;

        if (be.energyStorage.getEnergyStored() >= ENERGY_PER_TICK) {
            // Processing logic placeholder
            be.energyStorage.extractEnergy(ENERGY_PER_TICK, false);
            // Simulate cooking
            be.cookTime++;
            if (be.cookTime >= COOK_TIME_TOTAL) {
                be.cookTime = 0;
                // Output item logic here
            }
            be.setChanged();
        }
    }

    @Override
    public boolean validateStructure() {
        // Placeholder: 3x3x3 of Iron Blocks with this in the center-bottom?
        // For now, let's just make it assembleable.
        return true;
    }

    @Override public void assemble() { this.isAssembled = true; setChanged(); }
    @Override public void disassemble() { this.isAssembled = false; setChanged(); }
    @Override public boolean isAssembled() { return isAssembled; }

    @Override
    protected void saveAdditional(CompoundTag tag, HolderLookup.Provider registries) {
        super.saveAdditional(tag, registries);
        tag.putInt("energy", energyStorage.getEnergyStored());
        tag.putBoolean("assembled", isAssembled);
        tag.putInt("cookTime", cookTime);
    }

    @Override
    protected void loadAdditional(CompoundTag tag, HolderLookup.Provider registries) {
        super.loadAdditional(tag, registries);
        energyStorage.receiveEnergy(tag.getInt("energy"), false);
        isAssembled = tag.getBoolean("assembled");
        cookTime = tag.getInt("cookTime");
    }
}
